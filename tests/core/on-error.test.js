import { createController } from "../../src/create-controller.js";
import { assertMiddleware } from "../../src/middleware/assert.middleware.js";
import { asyncMiddleware } from "../../src/middleware/async.middleware.js";
import { logMiddleware } from "../../src/middleware/log.middleware.js";

const testData = new Map();

const ctrl = createController(assertMiddleware, logMiddleware(false), asyncMiddleware);

function throwError() {
  throw new Error('Test Error');
}

const handleErrorMiddleware = (next) => ({ id, fn, args, directives, error, resolved }) => {
  if (resolved) return next({ id, fn, args, directives, error, resolved });

  testData.set('HandledErrorMiddleware', true);

  next({ id, fn, args, directives, error, resolved: true });
  
  // Return a custom response from the error, allows for flow recovery from certain errors:
  return 'responseFromErrorHandler'
}

const skippedErrorMiddleware = (next) => ({ id, fn, args, directives, error, resolved }) => {
  if (resolved) return next({ id, fn, args, directives, error, resolved });

  testData.set('SkippedErrorMiddleware', true);

  const response = next({ id, fn, args, directives, error, resolved });

  return response;
}

const errorTestFlow = () => {
  testData.clear();

  return [
    // Throw error and assert the step response is the response generated by the error handler:
    { id: 'CatchError', fn: throwError, assert: { equal: 'responseFromErrorHandler' }, onError: [skippedErrorMiddleware, handleErrorMiddleware, handleErrorMiddleware2, handleErrorMiddleware3] },
      // Test that the error is caught and the error middleware is called:
    { id: 'ErrorHandledByMiddleware', fn: () => testData.get('HandledErrorMiddleware'), assert: { equal: true }},
      // Test that the caught error skips the next middleware:
    { id: 'HandledErrorSkippedByMiddleware', fn: () => testData.get('SkippedErrorMiddleware'), assert: { equal: undefined }},
  ];
}

export const errorTest = () => ctrl.push(errorTestFlow);
